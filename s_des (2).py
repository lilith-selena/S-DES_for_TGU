# -*- coding: utf-8 -*-
"""S_DES.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FfoSqM5KYOr7zbHC7eNLJrQLighnYXtv
"""

# Генерация ключей
def Permutation(permutation, key):   #фнкция реализующая в 
  global keyP                        #программе перестановки
  keyP = []                          #далее вызывается
  for i in range(0, len(permutation), 1):
    P = (int(permutation[i]))        #значения аргументов 
    keyP.append(key[(P-1)])          #подставляются в зависимости
  return keyP                        #от ключа и заданной 
                                     #перестновки

key = [1, 1, 1, 0, 1, 0, 0, 0, 1, 1] # ключ
permutation = (3, 5, 2, 7, 4, 10, 1, 9, 8, 6) # перестанока
Permutation(permutation, key)       # вызов функции перестановки

keygenleft = keyP[:5]  #После прямой перестановки ключ разделяется
keygenright = keyP[5:] #на две части по 5 бит.


def Slice(a, b): #Функция  для выполнения сдвига срезов влево
  global keyGL          # Каждая часть сдвигается влево на r бит,
  global keyGR          # где r - номер раунда
  keyGL = a[1:]+a[:1]
  keyGR = b[1:]+b[:1]
  return keyGL, keyGR
Slice(keygenleft, keygenright)

keyGen1 = keyGL + keyGR   # канкатинация после сдвига

# перестанока сжатия для первого раунда
permutation1 = (6, 3, 7, 4, 8, 5, 10, 9) 
Permutation(permutation1, keyGen1) #Вызывается функция перестановки
keyP1 = keyP                       # описанная выше
print(f'ключ для 1 раунда = {keyP1}') #ключ первого раунда

Slice(keyGL, keyGR) # сдвигаем срезы ключа на r = 2, для этого 
Slice(keyGL, keyGR) # дважды вызываем функцию Slice

keyGen2 = keyGL + keyGR   # канкатинация после сдвига

# перестанока сжатия для второго раунда
Permutation(permutation1, keyGen2) #Вызывается функция перестановки
keyP2 = keyP                       # описанная выше
print(f'ключ для 2 раунда  = {keyP2}') #ключ второго раунда

# ОСНОВНОЙ БЛОК ШИФРОВАНИЯ
# Начальная перестановка
TheText = [0,1,0,0,1,0,0,0]    # соответствует таблице ASCII
PBlokStart = (2,6,3,1,4,8,5,7) #  букве  H (01001000)
Permutation(PBlokStart, TheText) #Вызывается функция перестановки
Start = keyP 
print(f'Резуьтат после перестановки начало = {Start}') #начальные перестановки

# "Первый раунд шифра Фейстеля"
StartLift = Start[:4]    # Разделяем на 2 участка по 4 байта
StartRight = Start[4:]

#Расшитрения для левого блока
PBlokStartExpansion = (4,1,2,3,2,3,4,1) # P - блок расширения
Permutation(PBlokStartExpansion, StartLift) #Вызывается функция перестановки
ExpansionRound1 = keyP
print(f'Результат расшитения блока с 4 до 8 бит = {ExpansionRound1} ')

#Отбеливатель 1 
def Bleach(ExpansionRound,keyP):  # Функция осуществляющая сложение с 
  global bleach                   # использоавнием операции исключающее или
  bleach = []
  for i in range(0, (len(ExpansionRound)), 1 ):
    bleach.append((ExpansionRound[i])^(keyP[i]))
  return bleach

Bleach(ExpansionRound1, keyP1) #Вызов отбеливателя
bleach1 = bleach

# S-блоки можно представить в следующем виде удобном для 
# автоматизированного обращения к определенной позиции в матрице 
# так же ниже представленны словари для перевода из двоичной системы 
# в четверичную и обратно 
BinInt = {"00": 0, '01':1, "10" : 2, "11" :3}
SBlok1 = [[1,0,3,2],[3,2,1,0],[0,2,1,3],[3,1,3,2]]
IntBin = {0 : '00', 1 : '01', 2 : '10', 3 : '11'}
SBlok2 = [[0,1,2,3],[2,0,1,3],[3,0,1,0],[2,1,0,3]]

bleach_slice1 = bleach1[:4] #Выполняем разделение подавемого блока на две
bleach_slice2 = bleach1[4:] #равные части по 4 бита


def SblokSlice(bleach_slice): #функция выполняющая S замену"
  global a
  if bleach_slice[0] == 0 and bleach_slice[3] == 0:
    a = BinInt["00"]
  elif bleach_slice[0] == 0 and bleach_slice[3] == 1:
    a = BinInt["01"]
  elif bleach_slice[0] == 1 and bleach_slice[3] == 0:
    a = BinInt["10"]
  else:
    a = BinInt['11']
  return a

def Sbloki(bleach_slice):
  global b
  if bleach_slice[1] == 0 and bleach_slice[2] == 0:
    b = BinInt["00"]
    SblokSlice(bleach_slice)
  elif bleach_slice[1] == 0 and bleach_slice[2] == 1:
    b = BinInt["01"]
    SblokSlice(bleach_slice)
  elif bleach_slice[1] == 1 and bleach_slice[2] == 0:
    b = BinInt["10"]
    SblokSlice(bleach_slice)
  else:
    b = BinInt["11"]
    SblokSlice(bleach_slice)
  return a, b


#S - замена  1 блока 
Sbloki(bleach_slice1)
print(f'номер строки {a}, номер столбца {b},')
print(f'результат подстановки в 1 S - блоке {IntBin[SBlok1[a][b]]}')
s1=IntBin[SBlok1[a][b]]
#S - замена  2 блока
Sbloki(bleach_slice2)
print(f'номер строки {a}, номер столбца {b},')
print(f'результат подстановки в 2 S - блоке {IntBin[SBlok2[a][b]]}')
s2=IntBin[SBlok2[a][b]]

#канкатинация левого блока
SL = (s1 + s2)
StartLift = [int(a) for a in str(SL)]
StartLift, StartRight = StartRight, StartLift #левый и правый блок меняются
print(StartLift + StartRight)

# второй раунд шифра Фейстеля

# Блок расшитрения для левого блока
PBlokStartExpansion = (4,1,2,3,2,3,4,1)
Permutation(PBlokStartExpansion, StartLift)
ExpansionRound2 = keyP
print(f'Результат расшитения блока с 4 до 8 бит {ExpansionRound2} ')

#Отбеливатель 2 
Bleach(ExpansionRound2, keyP2)
bleach2 = bleach

bleach_slice1 = bleach2[:4] #Выполняем разделение подавемого блока на две
bleach_slice2 = bleach2[4:] #равные части по 4 бита

#S - замена  1 блока 
Sbloki(bleach_slice1)
print(f'номер строки {a}, номер столбца {b},')
print(f'результат подстановки в 1 S - блоке {IntBin[SBlok1[a][b]]}')
s3=IntBin[SBlok1[a][b]]

#S - замена  2 блока
Sbloki(bleach_slice2)
print(f'номер строки {a}, номер столбца {b},')
print(f'результат подстановки в 2 S - блоке {IntBin[SBlok2[a][b]]}')
s4=IntBin[SBlok2[a][b]]

#канкатинация правого блока
SL = (s3 + s4)
StartLift = [int(a) for a in str(SL)]
StartLift, StartRight = StartRight, StartLift #левый и правый блок меняются

# Конечная перестановка
FinalText = StartLift + StartRight
PBlokStart = (4,1,3,5,7,2,8,6)
Permutation(PBlokStart, FinalText) 
Final = keyP
print(f'P - блок финальная перестановка{Final}') #финальная перестановки